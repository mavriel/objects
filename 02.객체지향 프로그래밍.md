## 1. 영화 예매 시스템

### 요구사항 살펴보기

- 영화 - 영화 기본 정보
- 상영 - 관격이 영화를 관람하는 사건 (일시, 순번 등)

       영화/상영처럼 개념이 비슷한 경우에 코드도 섞이기 마련이다.
       보통 각종 status의 경우 범주가 다른데 섞여서 쓰인다. (남/여, 회사원/학생)

- 할인조건 - 가격의 할인 여부 결정, 여러 조건 할당 가능
  - 순서 조건
  - 기간 조건
- 할인정책 - 할인 요금 결정, 영화에 하나의 조건만 할당 가능
  - 금액 할인 정책
  - 비율 할인 정책
- 할인적용
  - 할인조건과 할인정책 두가지를 모두 만족하면 요금 할인

## 2. 객체지향 프로그래밍을 향해

### 협력, 객체, 클래스

- 객체지향은 객체를 지향하는 것 (클래스를 만드는 것이 아님)

1.  어떤 클래스가 필요한지 고민하기 전에 어떤 객체들이 필요한지 고민

    - 클래스 - 공통적인 상태와 행동을 공유하는 객체들을 추상화
    - 객체들이 어떤 상태와 행동을 갖는지 결정 필요

           백엔드를 담당하는 사람들중에서는 클래스도 아닌 DB테이블부터 고민하는 경우도 상당히 많다.

2.  객체를 독립적인 존재가 아니라 기능을 구현하기 위해 협력하는 공동체의 일원으로 봐야함

### 도메인의 구조를 따르는 프로그램 구조

- 도메인 - 사용자가 프로그램을 사용하는 분야
- 클래스 이름 - 도메인 개념의 이름과 동일하거나 유사하게 명명
- 클래스 관계 - 최대한 도메인 개념 사이에 맺어진 관계와 유사하게 설정

### 클래스 구현하기

- 인스턴스 변수 (private) / 메서드 (public)
- 훌륭한 클래스 설계의 핵심은 어느 부분을 공개하고 감출지를 결정

#### 자율적인 객체

- 객체의 특징

  1. 상태(state)와 행동(behavior)를 함께 갖는 존재
  2. 스스로 판단하고 행동하는 자율적인 존재

- 객체지향
  1. 캡슐화 - 객체라는 단위 안에 데이터와 기능을 한 덩어리로 묶음
  2. 접근제어 - 접근 수정자(public, protected, private 등)
     - 외부의 간섭을 최소화 하고, 자율적인 존재를 만들도록 함
  3. 일반적으로 객체의 상태는 숨기고 행동만 외부에 공개

#### 프로그래머의 자유

- 클래스 작성자
  - 새로운 데이터 타입을 프로그램에 추가
  - 클라이언트 프로그래머에게 필요한 부분만 공개하고 나머지는 숨김
- 클라이언트 프로그래머
  - 클래스 작성자가 추가한 데이터 타입 사용
  - 목표 : 클래스들을 엮어서 애플리케이션을 빠르고 안정적으로 구축
- 구현은닉(implementation hiding)
  - 숨겨놓은 부분은 접근하지 못하도록 해서, 클라이언트 프로그래머에 대한 영향은 걱정하지 않고, 마음데로 내부구현 변경 가능
  - 클라이언트 프로그래머는 인터페이스만 알고 있으면 된다.
  - 변경될 가능성이 있는 세부적인 구현 내용을 private에 감춤으로 변경에 의한 영향을 최소화 가능

### 협력하는 객체들의 공동체

- 협력(Collaboration) - 시스템의 어떤 기능을 구현하기 위해 객체들 사이에 이뤄지는 상호작용

### 협력에 관한 짧은 이야기

- 객체는 다른 객체의 인터페이스에 공개된 행동을 수행하도록 요청
- 요청을 받은 객체는 자율적인 방법에 따라 요청을 처리한 후 응답
- 메시지 - 다른 객체에게 보내는 요청
- 메서드 - 메시지를 받으면 실제 처리하는 자신만의 방법

## 3. 할인 요금 구하기

### 할인 요금 계산을 위한 협력 시작하기

- 할인 정책 판단용 클래스를 따로 뺀점에 촛점

### 할인 정책과 할인 조건

- DiscountPolicy 추상 클래스 사용해서 할인정책 구현
- TEMPLATE METHOD 패턴
  - 부모 클래스에 기본적인 알고리즘의 흐름을 구현하고 중간에 필요한 처리를 자식 클래스에 위임

### 할인 정책 구성하기

- 생성자를 사용해서, 정책은 하나, 조건은 여러개가 가능하도록 구현

## 4. 상속과 다형성

### 컴파일 시간 의존성과 실행 시간 의존성

- 코드(컴파일 시점)의 의존성과 실행 시점의 의존성은 서로 다를 수 있다.
- 코드의 의존성과 실행 시점의 의존성이 다를수록 코드를 이해하기 어려워 진다.
- 코드의 의존성과 실행 시점의 의존성이 다를수록 유연해지고 확장이 쉬워진다.

### 차이에 의한 프로그래밍

- 부모 클래스와 다른부분만을 추가해서 새로운 클래스를 쉽고 빠르게 만드는 방법

### 상속과 인터페이스

- 가치 - 부모클래스가 제공하는 모든 인터페이스를 자식 클래스가 물려받을 수 있기 때문
- (메서드/변수 재사용이 중요한 것이 아니다)
- 외부객체는 자식클래스를 부모클래스와 동일한 타입으로 간주 가능
- 업캐스팅 - 자식 클래스가 부모 클래스를 대신하는 것

### 다형성

- 동일한 메시지에 대해서 어떤 메서드가 실행될 것인지를 결정하는 것은 수신하는 객체가 결정

### 인터페이스와 다형성

## 5. 추상화와 유연성

### 추상화의 힘

1. 추상화의 계층만 따로 떼어 놓고 살펴보면 요구사항의 정책을 높은 수준에서 서술 가능
2. 추상화를 이용하면 설계가 좀더 유연

### 유연한 설계

- 할인을 사용하지 않는 경우의 처리를 위해 할인하지않는 다는 정책 클래스(NoneDiscountPolicy) 추가
- 아무런 코드의 수정없이 새로운 정책의 추가가 가능
- 예제는 리팩토링 10.5 특이케이스 추가하기에 해당

### 추상 클래스와 인터페이스 트레이드오프

- 앞의 정책클래스들에서 NoneDiscountPolicy가 무엇을 반환해도 부모클래스에서는 어차피 0을 반환
- 개념적으로 섞인 부분이 있기에 이를 인터페이스를 사용해 해결
- 이상적으로는 인터페이스 사용한 설계가 좋지만, 하나의 클래스를 위해 인터페이스를 추가하는 것이 과할수도 있다.
- 이런 트레이드 오프를 고민할 필요

### 코드 재사용

### 상속

- 문제점
  1. 캡슐화를 위반
     - 상속을 이용하기 위해서는 부모 클래스의 구조를 알아야 한다.
     - 부모 클래스의 구현이 자식 클래스에 노출되기에 캡슐화 약화
     - 부모 클래스와 자식 클래스가 강하게 결합되기에 부모 변경시 자식도 변경 가능성 높다.
  2. 유연하지 않다.
     - 컴파일 시점에 부모/자식 관계가 결정

### 합성

- 인터페이스에 정의된 메시지를 통해서만 코드를 재사용하는 방법
- 상속의 문제를 해결
  1. 인터페이스에 정의된 메시지를 통해서만 재사용이 가능하기에 캡슐화
  2. 인스턴스를 교체하는 것이 쉽기에 설계가 유연
