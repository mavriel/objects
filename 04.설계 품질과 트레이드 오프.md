# 04. 설계 품질과 트레이드오프

## 1. 데이터 중심의 영화 예매 시스템

1. 상태(데이터)를 분할의 중심축으로
   - 자신이 갖고있는 데이터를 조작하는 데 필요한 오퍼레이션 정의
   - 객체의 상태에 초점
   - 객체를 독립된 데이터 덩어리로 인식
   - 객체의 상태 --> 구현 --> 변하기 쉽다 --> 상태변경으로 인터페이스가 변함 --> 변경에 취약
2. 책임을 분할의 중심축으로
   - 다른 객체가 요청할 수 있는 오퍼레이션을 위해 필요한 상태 보관
   - 객체의 행동에 초점
   - 객체를 협력하는 공동체의 일원으로 인식
   - 객체의 책임 --> 인터페이스 --> 구현의 변경으로 인한 외부 영향이 최소화

### 데이터를 준비하자

- 데이터 중심 설계
  - 객체 내부에 저장되는 데이터를 기반으로 시스템을 분할하는 방법
  - 객체가 내부에 저장해야 하는 데이터가 무엇인지 결정하는 것으로 시작

* 예제
  - 필요할것 같은 데이터를 만들고, 캡슐화를 위해 접근자, 수정자를 작성
  - 모든 클래스들을 비슷하게 구현

### 영화를 예매하자

- 예매절차를 구현하는 클래스를 만들고 함수 하나에서 실행한다.

## 2. 설계 트레이드오프

### 캡슐화

- 이유 : 객체의 내부 구현을 외부로부터 감추기 위해서
- 구현
  - 변경가능성이 높다.
- 인터페이스
  - 상대적으로 변경 가능성이 적다.
- 변경될 수 있는 모든 것을 캡슐화하는 것이 객체지향 설계의 핵심

### 응집도와 결합도

- 응집도
  - 모듈에 포함된 내부 요소들이 연관되어 있는 정도
  - 객체 또는 클래스에 얼마나 관련 높은 책임들을 할당했는지
- 결합도
  - 의존성 정도를 나타내며 다른 모듈에 대해 얼마나 많이 알고 있는지를 나타내는 척도
  - 객체 또는 클래스가 협력에 필요한 적절한 수준의 관계만을 유지하는지
- 높은 응집도와 낮은 결합도의 이유
  - 설계를 변경하기 쉽게 만들어준다.
  - 응집도가 높으면, 변경의 대상과 범위가 명확해져서 코드 변경이 쉬워진다.
  - 결합도가 낮으면, 한 모듈의 변경의 다른 모듈에 영향을 덜 미친다.
- 상관없는 경우
  - 변경될 확률이 매우 적은 모듈을 의존
    - 언어에서 제공하는 라이브러리
    - 성숙단계에 접어든 프레임워크

## 3. 데이터 중심의 영화 예매 시스템의 문제점

### 캡슐화 위반

- 추측에 의한 설계 전력
  - 협력을 고려하지 않고, 다양한 상황을 막연히 추측해 설계
  - 내부 구현이 인터페이스에 노출

### 높은 결합도

- 어떤 데이터 객체를 변경해도 제어객체를 변경해야 한다.
- 어떤 변경이라도 시스템 전체에 영향을 준다.

### 낮은 응집도

- 코드를 수정후에 아무런 상관없는 코드에 문제가 발생하는 것이 모듈의 응집도가 낮을 때 발생하는 대표적인 증상
- 하나의 요구사항 변경을 반영하기 위해 동시에 여러 모듈을 수정해야 됨

## 4. 자율적인 객체를 향해

### 캡슐화를 지켜라

- 객체는 자신이 어떤 데이터를 가지고 있는지 내부에 캡슐화하고 외부에 공개해서는 안 된다.
- 객체는 스스로의 상태를 책임져야 하면 외부에서는 인터페이스에 정의된 메서드를 통해서만 상태에 전급할 수 있어야 한다.

### 스스로 자신의 데이터를 책임지는 객체

- 객체가 어떤 데이터를 포함해야 하는가?
- 객체가 데이터에 대해 수행해야 하는 오퍼레이션은 무엇인가?
- 객체가 자신의 데이터를 제공하지 않고, 오퍼레이션에 따른 결과물을 주도록 하면 훨씬 좋은 캡슐화로 구현

## 5. 하지만 여전히 부족하다

### 캡슐화 위반

- 내부구현은 인터페이스에 노출시키고 있다
  > 캡슐화는 변할 수 있는 어떤 것이라도 감추는 것
  > 설계에서 변하는 것이 무엇인지 고려하고 변하는 개념을 캡슐화해야 한다.

### 높은 결합도

- 캡슐화 위반으로 인해 여러 클래스/객체간의 결합도가 높을 수 밖에 없다.
- 유연한 설계를 위해서 캡슐화를 첫번째 목표로 해야한다.

### 낮은 응집도

- 여전히 하나의 변경을 수용하기 위해 동시에 여러 곳을 변경해야 한다.

## 6. 데이터 중심 설계의 문제점

1. 너무 이른 시기에 데이터에 관해 결정하도록 강요한다.
2. 협력을 고려하지 않고 객체를 고립시킨체 오퍼레이션을 결정한다.

### 데이터 중심 설계는 객체의 행동보다 상태에 초점을 맞춘다

- 일반적으로 데이터와 기능을 분리하는 절차적 프로그램 방식을 따른다.
- 데이터 사용로직을 별도 객체에서 구현해서 캡슐화가 깨진다.
- 같은 객체에서 처리하더라도 결국 같은 방식으로 구현해서 같은 문제 발생

### 데이터 중심 설계는 객체를 고립시킨 채 오퍼레이션을 정의하도록 만든다

- 올바른 객체지향 설계의 무게 중심은 객체 외부에 맞춰줘야 한다.
- 이미 구션이 결정된 상태에서 인터페이스를 억지로 끼워맞출수 밖에 없다.
- 객체의 인터페이스에 구현이 노출돼 있기에 현력이 구현 세부사항에 종속되어 있고, 따라서 구현이 변경되면 협력하는 모두가 영향을 받는다.
